script;

use std::assert::assert;
use std::b256_ops::*;
use std::constants::ZERO;
use std::chain::log_b256;


fn main() -> bool {
    let one = 1;
    let two = 2;
    let three = 3;
    let four = 4;

    let test_val: b256 = 0x0000000000000001_0000000000000002_0000000000000003_0000000000000004;

    let composed = compose(one, two, three, four);
    assert(composed == test_val);

    let(w1, w2, w3, w4) = decompose(test_val);
    assert(w1 == one);
    assert(w2 == two);
    assert(w3 == three);
    assert(w4 == four);

    let a = 0b1000000000000001_1000000000000001_1000000000000001_1000000000000001_1000000000000001_1000000000000001_1000000000000001_1000000000000001_1000000000000001_1000000000000001_1000000000000001_1000000000000001_1000000000000001_1000000000000001_1000000000000001_1000000000000001;

    let b = 0b0000000100000001_0000000100000001_0000000100000001_0000000100000001_0000000100000001_0000000100000001_0000000100000001_0000000100000001_0000000100000001_0000000100000001_0000000100000001_0000000100000001_0000000100000001_0000000100000001_0000000100000001_0000000100000001;

    let c = 0b0000000000000001_0000000000000001_0000000000000001_0000000000000001_0000000000000001_0000000000000001_0000000000000001_0000000000000001_0000000000000001_0000000000000001_0000000000000001_0000000000000001_0000000000000001_0000000000000001_0000000000000001_0000000000000001;

    let d = 0b1000000100000000_1000000100000000_1000000100000000_1000000100000000_1000000100000000_1000000100000000_1000000100000000_1000000100000000_1000000100000000_1000000100000000_1000000100000000_1000000100000000_1000000100000000_1000000100000000_1000000100000000_1000000100000000;

    let e = 0b1000000100000001_1000000100000001_1000000100000001_1000000100000001_1000000100000001_1000000100000001_1000000100000001_1000000100000001_1000000100000001_1000000100000001_1000000100000001_1000000100000001_1000000100000001_1000000100000001_1000000100000001_1000000100000001;

    let f = 0b1000000000000000_1000000000000000_1000000000000000_1000000000000000_1000000000000000_1000000000000000_1000000000000000_1000000000000000_1000000000000000_1000000000000000_1000000000000000_1000000000000000_1000000000000000_1000000000000000_1000000000000000_1000000000000000;

    let addr_1 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
    let addr_2 = 0x3333333333333333333333333333333333333333333333333333333333333333;
    let addr_3 = 0x1111111111111111111111111111111111111111111111111111111111111111;
    let addr_4 = 0x2222222222222222222222222222222222222222222222222222222222222222;

    // let c = a & b;
    // log_b256(c);
    assert(a & b == c);
    assert(a & c == c);
    assert(b & c == c);
    assert(a & d == a);
    assert(d & b == b);
    assert(a & d == f);
    assert(f & e == f);
    assert(addr_1 & addr_2 == addr_2);
    assert(addr_4 & addr_3 == ZERO);
    assert(addr_1 & addr_4 == addr_4);

    assert(a | b == e);
    assert(a | d == e);
    assert(a | c == a);
    // assert(c | f == a); should be true, but fails with:
    ///thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Immediate12TooLarge { val: 4287, span: Span { src (ptr): 0x600003d81570, path: None, start: 0, end: 0, as_str(): "" } }', sway-core/src/asm_lang/virtual_ops.rs:849:18
    // note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    // assert(c | d == e);

    // assert(addr_1 | addr_2 == addr_1);
    // assert(addr_2 | addr_3 == addr_2);
    // assert(addr_3 | addr_4 == addr_2);



    assert(a ^ b == e);

    true
}

/**
A: 0x1000000000000001100000000000000110000000000000011000000000000001:
0001000000000000000000000000000000000000000000000000000000000001000100000000000000000000000000000000000000000000000000000000000100010000000000000000000000000000000000000000000000000000000000010001000000000000000000000000000000000000000000000000000000000001

B: 0x0000000100000001000000001000000100000000100000010000000010000001:
000100000000000000000000000000000001000000000000000000000000000000000001000000000000000000000000000100000000000000000000000000000000000100000000000000000000000000010000000000000000000000000000000000010000000000000000000000000001


C: 0x0000000000000001000000000000000100000000000000010000000000000001:
0001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001
*/